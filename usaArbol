unit USA_ARBOL;

interface

uses CRT, UNIT_ARBOL;

PROCEDURE CARGAR_ARBOL(VAR RAIZ:T_PUNT);
PROCEDURE CONSULTA (VAR RAIZ:T_PUNT);
PROCEDURE LISTAR (RAIZ:T_PUNT);
PROCEDURE BAJA(VAR RAIZ:T_PUNT);


implementation

 PROCEDURE AGREGAR_NODO (VAR RAIZ:T_PUNT);
 VAR
 X:CHAR;
 BEGIN
 CLRSCR;
 WRITE ('INGRESE DATO: ');
 READLN (X);
 AGREGAR(RAIZ, X);
 end;
 PROCEDURE MUESTRA_DATOS (x:T_DATO);
 BEGIN
 WRITELN (X)
 END;
 PROCEDURE CARGAR_ARBOL(VAR RAIZ:T_PUNT);
 VAR CAR,TECLA: CHAR;
 BEGIN
 CLRSCR;
 WRITE ('INGRESA? PRESIONE N PARA SALIR: ');
 READLN (TECLA);
 WHILE NOT (ARBOL_LLENO (RAIZ)) AND (TECLA<> 'N') DO
 BEGIN
 CLRSCR;
 WRITE ('INGRESA CARACTER: ');
 READLN (CAR);
 AGREGAR (RAIZ,CAR);
 WRITE ('CONTINUA? PRESIONE N PARA SALIR: ');
 READLN (TECLA);
 end;
 END;

 PROCEDURE CONSULTA (VAR RAIZ:T_PUNT);
 VAR ENC:BOOLEAN; CAR,X:T_DATO;
 BEGIN
 WRITE('BUSCAR: ');
 READLN (CAR);
 PREORDEN (RAIZ,CAR,ENC,X);
 IF NOT ENC  THEN WRITELN ('NO SE ENCUENTRA' )
 ELSE MUESTRA_DATOS (X);
 readkey;
  end;

  PROCEDURE BUSCAR (RAIZ:T_PUNT);
  BEGIN
  IF ARBOL_VACIO (RAIZ) THEN WRITE ('ARBOL VACIO')
  ELSE CONSULTA(RAIZ);
  READKEY
  end;

  PROCEDURE LISTAR (RAIZ:T_PUNT);
  BEGIN
  IF NOT ARBOL_VACIO (RAIZ) THEN INORDEN (RAIZ)
  ELSE WRITELN ('ARBOL VACIO');
  READKEY
  END;

   PROCEDURE BAJA1(VAR RAIZ:T_PUNT);
  VAR
    POS:T_PUNT;
    ENC:BOOLEAN; CAR,X:T_DATO;RESP:CHAR;
    BEGIN
      WRITE('BUSCAR: ');
      READLN (CAR);
      PREORDEN (RAIZ,CAR,ENC,X);
      IF NOT ENC  THEN WRITELN ('NO SE ENCUENTRA' )
      ELSE  BEGIN
            MUESTRA_DATOS (X);
            WRITE ('ESTA SEGURO DE ELIMINAR LOS DATOS? S/N ');
            READLN (RESP);
            IF upcase(RESP) = 'S' THEN
                            SUPRIME(RAIZ,CAR);
            end;
  end;

   PROCEDURE BAJA(VAR RAIZ:T_PUNT);
    BEGIN
    IF ARBOL_VACIO (RAIZ) THEN WRITE ('ARBOL VACIO')
     ELSE BAJA1(RAIZ);
    READKEY
   end;
end.

